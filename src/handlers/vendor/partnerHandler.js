import Partner from '../../models/Partner.js';
import { PartnerCache } from '../../services/cache/strategies/partnerCache.js';
import { SubscriptionCache } from '../../services/cache/strategies/subscriptionCache.js';
import cacheService from '../../services/cache/cacheService.js';
import websocketService from '../../services/websocketService.js';

// Fonction utilitaire pour calculer la distance
const calculateDistance = (lat1, lng1, lat2, lng2) => {
  const R = 6371; // Rayon de la Terre en km
  const dLat = (lat2 - lat1) * Math.PI / 180;
  const dLng = (lng2 - lng1) * Math.PI / 180;
  const a = 
    Math.sin(dLat/2) * Math.sin(dLat/2) +
    Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * 
    Math.sin(dLng/2) * Math.sin(dLng/2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
  return R * c;
};

// Fonction pour calculer la r√©duction utilisateur
const calculateUserDiscount = (partnerDiscount, userPlan) => {
  if (userPlan === "premium") {
    return partnerDiscount; // Acc√®s complet
  }
  
  const maxDiscounts = {
    basic: 5,
    super: 10,
    premium: 100 // Pas de limite
  };
  
  const maxDiscount = maxDiscounts[userPlan] || 0;
  return Math.min(partnerDiscount, maxDiscount);
};

// Rechercher des partenaires
export const searchPartnersHandler = async (event) => {
  const { lat, lng, radius = 10, category, city, name, limit = 20 } = event.args;
  const userId = event.context.user.id;
  
  try {
    // R√©cup√©rer le plan utilisateur avec cache
    const subscriptionFeatures = await SubscriptionCache.getSubscriptionFeatures(userId);
    const userPlan = subscriptionFeatures?.isActive ? subscriptionFeatures.plan : 'free';
    
    console.log('Recherche avec filtres:', { lat, lng, radius, category, city, name, limit });
    
    // Recherche avec cache
    const partners = await PartnerCache.searchPartners({
      lat, lng, radius, category, city, name, limit
    });
    
    console.log('Partenaires trouv√©s:', partners.length);
    
    const result = partners.map(partner => {
      const finalDiscount = calculateUserDiscount(partner.discount, userPlan);
      
      let distance = null;
      if (lat && lng && partner.location?.coordinates) {
        const partnerLng = partner.location.coordinates[0];
        const partnerLat = partner.location.coordinates[1];
        distance = calculateDistance(parseFloat(lat), parseFloat(lng), partnerLat, partnerLng);
      }
      
      return {
        id: partner._id,
        name: partner.name,
        category: partner.category,
        address: partner.address,
        city: partner.city,
        zipCode: partner.zipCode,
        location: {
          latitude: partner.location?.coordinates[1],
          longitude: partner.location?.coordinates[0]
        },
        distance: distance ? Math.round(distance * 100) / 100 : null,
        logo: partner.logo,
        description: partner.description,
        phone: partner.phone,
        website: partner.website,
        offeredDiscount: partner.discount,
        userDiscount: finalDiscount,
        isPremiumOnly: partner.discount > 15,
        canAccessFullDiscount: userPlan === "premium" || partner.discount <= (userPlan === "super" ? 10 : userPlan === "basic" ? 5 : 0),
        needsSubscription: userPlan === "free" && partner.discount > 0,
        createdAt: partner.createdAt
      };
    });
    
    // Trier par distance si g√©olocalis√©
    if (lat && lng) {
      result.sort((a, b) => (a.distance || 0) - (b.distance || 0));
    }
    
    return {
      partners: result,
      userPlan,
      searchParams: {
        location: lat && lng ? { lat: parseFloat(lat), lng: parseFloat(lng) } : null,
        radius: parseFloat(radius),
        category,
        city,
        name
      },
      totalFound: result.length,
      isGeoSearch: !!(lat && lng)
    };
  } catch (error) {
    console.error('Erreur recherche partenaires:', error);
    throw error;
  }
};

// Lister tous les partenaires
export const getPartnersHandler = async (event) => {
  const { category } = event.args;
  const userId = event.context.user.id;
  
  try {
    // üî• CACHE GLOBAL: R√©cup√©rer les donn√©es brutes (partag√© entre tous) v2
    let partners;
    if (category) {
      const cacheKey = `category:${category}:v2`;
      partners = await cacheService.getOrSet(
        cacheKey,
        'partners',
        async () => {
          const partners = await Partner.find({ 
            category, 
            isActive: true 
          }).sort({ name: 1 });
          return partners.map(p => {
            const obj = p.toObject();
            obj._id = obj._id.toString();
            if (obj.owner) obj.owner = obj.owner.toString();
            return obj;
          });
        }
      );
    } else {
      // Cache global pour tous les partenaires v2
      partners = await cacheService.getOrSet(
        'all_partners:v2',
        'partners', 
        async () => {
          const partners = await Partner.find({ isActive: true }).sort({ name: 1 }).limit(100);
          return partners.map(p => {
            const obj = p.toObject();
            obj._id = obj._id.toString();
            if (obj.owner) obj.owner = obj.owner.toString();
            return obj;
          });
        }
      );
    }
    
    // üë§ CALCUL UTILISATEUR: Apr√®s r√©cup√©ration cache (pas cach√©)
    const subscriptionFeatures = await SubscriptionCache.getSubscriptionFeatures(userId);
    const userPlan = subscriptionFeatures?.isActive ? subscriptionFeatures.plan : 'free';
    
    const result = partners.map(partner => {
      const finalDiscount = calculateUserDiscount(partner.discount, userPlan);
      
      return {
        id: partner._id,
        name: partner.name,
        category: partner.category,
        address: partner.address,
        city: partner.city,
        zipCode: partner.zipCode,
        phone: partner.phone || '',
        discount: partner.discount,
        logo: partner.logo,
        description: partner.description,
        website: partner.website,
        location: partner.location ? {
          latitude: partner.location.coordinates[1],
          longitude: partner.location.coordinates[0]
        } : null,
        offeredDiscount: partner.discount,
        userDiscount: finalDiscount,
        isPremiumOnly: partner.discount > 15,
        canAccessFullDiscount: userPlan === "premium" || partner.discount <= (userPlan === "super" ? 10 : userPlan === "basic" ? 5 : 0),
        needsSubscription: userPlan === "free" && partner.discount > 0,
        isActive: partner.isActive,
        createdAt: partner.createdAt
      };
    });
    
    return {
      partners: result,
      userPlan: userPlan,
      totalPartners: result.length,
      availableCategories: [...new Set(partners.map(p => p.category))]
    };
  } catch (error) {
    console.error('Erreur r√©cup√©ration partenaires:', error);
    throw error;
  }
};

// üî• D√âTAIL D'UN PARTENAIRE AVEC CACHE PARTAG√â PAR PLAN UTILISATEUR - OPTIMIS√â
export const getPartnerHandler = async (event) => {
  const { id } = event.args;
  const userId = event.context.user.id;
  
  try {
    console.log(`üîç getPartnerHandler: partnerId=${id}, userId=${userId}`);
    
    // üéØ √âTAPE 1: R√©cup√©rer le plan utilisateur en PREMIER (optimis√© avec cache)
    const subscriptionFeatures = await SubscriptionCache.getSubscriptionFeatures(userId);
    const userPlan = subscriptionFeatures?.isActive ? subscriptionFeatures.plan : 'free';
    
    console.log(`üë§ Plan utilisateur: ${userPlan}`);
    
    // üî• √âTAPE 2: Cache partag√© par plan utilisateur - CL√â INTELLIGENTE
    const cacheKey = `partner_detail:${id}:${userPlan}`;
    
    console.log(`üîë Cl√© de cache partag√©: ${cacheKey}`);
    
    // Essayer de r√©cup√©rer depuis le cache partag√©
    const cachedPartnerDetail = await cacheService.getOrSet(
      cacheKey,
      'partners',
      async () => {
        console.log(`üíæ Cache MISS pour partner ${id} plan ${userPlan} - G√©n√©ration des donn√©es`);
        
        // üéØ R√©cup√©rer le partenaire - SOIT par ID MongoDB SOIT par nom
        let partner;
        
        // V√©rifier si c'est un ID MongoDB valide (24 caract√®res hexad√©cimaux)
        const isValidObjectId = /^[0-9a-fA-F]{24}$/.test(id);
        
        if (isValidObjectId) {
          // Recherche par ID MongoDB
          console.log(`üîë Recherche par ID MongoDB: ${id}`);
          partner = await PartnerCache.getPartner(id);
        } else {
          // Recherche par nom (slug d√©cod√©)
          const partnerName = decodeURIComponent(id).replace(/-/g, ' ');
          console.log(`üìù Recherche par nom: ${partnerName}`);
          
          // Recherche directe dans la base de donn√©es par nom
          const partnerFromDB = await Partner.findOne({ 
            name: { $regex: new RegExp(`^${partnerName}$`, 'i') },
            isActive: true 
          });
          
          if (partnerFromDB) {
            partner = {
              ...partnerFromDB.toObject(),
              _id: partnerFromDB._id.toString()
            };
          }
        }
        
        if (!partner) {
          throw new Error('Partenaire introuvable');
        }
        
        if (!partner.isActive) {
          throw new Error('Ce partenaire n\'est plus disponible');
        }
        
        // Calculer les donn√©es adapt√©es au plan utilisateur
        const finalDiscount = calculateUserDiscount(partner.discount, userPlan);
        
        const partnerDetail = {
          id: partner._id,
          name: partner.name,
          category: partner.category,
          address: partner.address,
          city: partner.city,
          zipCode: partner.zipCode,
          discount: partner.discount,
          logo: partner.logo,
          description: partner.description,
          phone: partner.phone,
          website: partner.website,
          location: partner.location ? {
            latitude: partner.location.coordinates[1],
            longitude: partner.location.coordinates[0]
          } : null,
          offeredDiscount: partner.discount,
          userDiscount: finalDiscount,
          isPremiumOnly: partner.discount > 15,
          userPlan: userPlan,
          canAccessFullDiscount: userPlan === "premium" || partner.discount <= (userPlan === "super" ? 10 : userPlan === "basic" ? 5 : 0),
          needsSubscription: userPlan === "free" && partner.discount > 0,
          createdAt: partner.createdAt,
          updatedAt: partner.updatedAt,
          // ‚úÖ M√©tadonn√©es de cache pour debug
          _cacheInfo: {
            generatedAt: new Date().toISOString(),
            forPlan: userPlan,
            cacheKey: cacheKey,
            source: 'DB_GENERATION',
            searchMethod: isValidObjectId ? 'BY_ID' : 'BY_NAME'
          }
        };
        
        console.log(`‚úÖ Donn√©es g√©n√©r√©es pour plan ${userPlan}:`, {
          partnerId: id,
          partnerName: partner.name,
          originalDiscount: partner.discount,
          userDiscount: finalDiscount,
          userPlan,
          searchMethod: isValidObjectId ? 'BY_ID' : 'BY_NAME'
        });
        
        return partnerDetail;
      },
      1800 // TTL: 30 minutes - Cache partag√© entre users du m√™me plan
    );
    
    // Mettre √† jour les m√©tadonn√©es si c'√©tait un cache hit
    if (cachedPartnerDetail._cacheInfo && cachedPartnerDetail._cacheInfo.source === 'DB_GENERATION') {
      console.log(`üéØ Cache HIT: Partner ${id} pour plan ${userPlan} depuis cache partag√©`);
      cachedPartnerDetail._cacheInfo.source = 'SHARED_CACHE_HIT';
      cachedPartnerDetail._cacheInfo.retrievedAt = new Date().toISOString();
    }
    
    console.log(`‚úÖ Partner detail ${id} pour plan ${userPlan} retourn√©`);
    
    return cachedPartnerDetail;
    
  } catch (error) {
    console.error('‚ùå Erreur r√©cup√©ration partenaire:', error);
    throw error;
  }
};

// Lister les cat√©gories
export const getCategoriesHandler = async () => {
  try {
    const categories = await PartnerCache.getCategories();
    
    return {
      categories,
      total: categories.length
    };
  } catch (error) {
    console.error('Erreur r√©cup√©ration cat√©gories:', error);
    throw error;
  }
};

// Lister les villes disponibles
export const getCitiesHandler = async () => {
  try {
    const cities = await Partner.distinct("city", { isActive: true });
    
    return {
      cities: cities.filter(city => city && city.trim()).sort(),
      total: cities.length
    };
  } catch (error) {
    console.error('Erreur r√©cup√©ration villes:', error);
    throw error;
  }
};

// Coordonn√©es des villes avec partenaires
export const getCityCoordinatesHandler = async () => {
  try {
    const cityData = await Partner.aggregate([
      { $match: { isActive: true } },
      {
        $group: {
          _id: "$city",
          coordinates: { $first: "$location.coordinates" },
          count: { $sum: 1 }
        }
      },
      { $sort: { _id: 1 } }
    ]);
    
    const cityCoordinates = {};
    cityData.forEach(city => {
      if (city._id && city.coordinates && city.coordinates.length === 2) {
        cityCoordinates[city._id] = {
          latitude: city.coordinates[1],
          longitude: city.coordinates[0],
          partnerCount: city.count
        };
      }
    });
    
    return {
      cityCoordinates,
      totalCities: Object.keys(cityCoordinates).length,
      cities: Object.keys(cityCoordinates).sort()
    };
  } catch (error) {
    console.error('Erreur r√©cup√©ration coordonn√©es villes:', error);
    throw error;
  }
};

// üöÄ NOUVEAU: Cr√©er un partenaire avec notification WebSocket
export const createPartnerHandler = async (event) => {
  const { input } = event.args;
  const userId = event.context.user.id;
  const userRole = event.context.user.role;
  
  try {
    console.log('üöÄ Cr√©ation d\'un nouveau partenaire:', input.name);
    
    // V√©rifier les permissions
    if (userRole !== 'admin' && userRole !== 'vendor') {
      throw new Error('Non autoris√© : seuls les admins et vendeurs peuvent cr√©er des partenaires');
    }
    
    // Pr√©parer les donn√©es du partenaire
    const partnerData = {
      ...input,
      owner: userId,
      isActive: true,
      createdAt: new Date(),
      updatedAt: new Date()
    };
    
    // Ajouter la g√©olocalisation si fournie
    if (input.latitude && input.longitude) {
      partnerData.location = {
        type: 'Point',
        coordinates: [input.longitude, input.latitude]
      };
    }
    
    // Cr√©er le partenaire en base
    const newPartner = await Partner.create(partnerData);
    
    console.log('‚úÖ Partenaire cr√©√©:', newPartner._id);
    
    // üî• INVALIDATION CACHE
    await PartnerCache.invalidateCache();
    await cacheService.invalidateGroup('partners');
    
    // üöÄ NOTIFICATION WEBSOCKET - Nouveau partenaire cr√©√©
    await websocketService.notifyPartnerChange(
      newPartner._id.toString(),
      'created',
      {
        id: newPartner._id.toString(),
        name: newPartner.name,
        category: newPartner.category,
        city: newPartner.city,
        discount: newPartner.discount,
        logo: newPartner.logo
      }
    );
    
    // üéØ NOTIFICATION PAR G√âOLOCALISATION
    await websocketService.notifyPartnerChangeByLocation(
      newPartner._id.toString(),
      'created',
      newPartner,
      newPartner.city,
      newPartner.category
    );
    
    // üîÑ NOTIFICATION INVALIDATION CACHE
    await websocketService.notifyCacheInvalidation([
      'all_partners',
      `category:${newPartner.category}`,
      `city:${newPartner.city}`
    ]);
    
    console.log('üì° Notifications WebSocket envoy√©es pour nouveau partenaire');
    
    return {
      success: true,
      message: 'Partenaire cr√©√© avec succ√®s',
      partner: {
        id: newPartner._id.toString(),
        name: newPartner.name,
        category: newPartner.category,
        address: newPartner.address,
        city: newPartner.city,
        discount: newPartner.discount,
        isActive: newPartner.isActive,
        createdAt: newPartner.createdAt.toISOString()
      }
    };
    
  } catch (error) {
    console.error('‚ùå Erreur cr√©ation partenaire:', error);
    throw error;
  }
};

// üîÑ NOUVEAU: Mettre √† jour un partenaire avec notification WebSocket
export const updatePartnerHandler = async (event) => {
  const { id, input } = event.args;
  const userId = event.context.user.id;
  const userRole = event.context.user.role;
  
  try {
    console.log(`üîÑ Mise √† jour partenaire ${id}:`, Object.keys(input));
    
    // V√©rifier les permissions
    if (userRole !== 'admin' && userRole !== 'vendor') {
      throw new Error('Non autoris√© : seuls les admins et vendeurs peuvent modifier des partenaires');
    }
    
    // R√©cup√©rer le partenaire existant
    const existingPartner = await Partner.findById(id);
    if (!existingPartner) {
      throw new Error('Partenaire introuvable');
    }
    
    // V√©rifier que le vendeur ne peut modifier que ses propres partenaires
    if (userRole === 'vendor' && existingPartner.owner.toString() !== userId) {
      throw new Error('Non autoris√© : vous ne pouvez modifier que vos propres partenaires');
    }
    
    // Pr√©parer les donn√©es de mise √† jour
    const updateData = {
      ...input,
      updatedAt: new Date()
    };
    
    // Mettre √† jour la g√©olocalisation si fournie
    if (input.latitude && input.longitude) {
      updateData.location = {
        type: 'Point',
        coordinates: [input.longitude, input.latitude]
      };
    }
    
    // Effectuer la mise √† jour
    const updatedPartner = await Partner.findByIdAndUpdate(
      id,
      updateData,
      { new: true, runValidators: true }
    );
    
    console.log('‚úÖ Partenaire mis √† jour:', id);
    
    // üî• INVALIDATION CACHE
    await PartnerCache.invalidatePartner(id);
    await PartnerCache.invalidateCache();
    await cacheService.invalidateGroup('partners');
    
    // üöÄ NOTIFICATION WEBSOCKET - Partenaire modifi√©
    await websocketService.notifyPartnerChange(
      id,
      'updated',
      {
        id: updatedPartner._id.toString(),
        name: updatedPartner.name,
        category: updatedPartner.category,
        city: updatedPartner.city,
        discount: updatedPartner.discount,
        changes: Object.keys(input),
        updatedAt: updatedPartner.updatedAt.toISOString()
      }
    );
    
    // üéØ NOTIFICATION PAR G√âOLOCALISATION (si ville/cat√©gorie modifi√©es)
    if (input.city || input.category) {
      await websocketService.notifyPartnerChangeByLocation(
        id,
        'updated',
        updatedPartner,
        updatedPartner.city,
        updatedPartner.category
      );
    }
    
    // üîÑ NOTIFICATION INVALIDATION CACHE
    await websocketService.notifyCacheInvalidation([
      `partner:${id}`,
      'all_partners',
      `category:${updatedPartner.category}`,
      `city:${updatedPartner.city}`,
      `partner_detail:${id}:*` // Invalider tous les caches de d√©tail pour ce partenaire
    ]);
    
    console.log('üì° Notifications WebSocket envoy√©es pour mise √† jour partenaire');
    
    return {
      success: true,
      message: 'Partenaire mis √† jour avec succ√®s',
      partner: {
        id: updatedPartner._id.toString(),
        name: updatedPartner.name,
        category: updatedPartner.category,
        address: updatedPartner.address,
        city: updatedPartner.city,
        discount: updatedPartner.discount,
        isActive: updatedPartner.isActive,
        updatedAt: updatedPartner.updatedAt.toISOString()
      }
    };
    
  } catch (error) {
    console.error(`‚ùå Erreur mise √† jour partenaire ${id}:`, error);
    throw error;
  }
};

// üóëÔ∏è NOUVEAU: Supprimer un partenaire avec notification WebSocket
export const deletePartnerHandler = async (event) => {
  const { id } = event.args;
  const userId = event.context.user.id;
  const userRole = event.context.user.role;
  
  try {
    console.log(`üóëÔ∏è Suppression partenaire ${id}`);
    
    // V√©rifier les permissions (seuls les admins peuvent supprimer)
    if (userRole !== 'admin') {
      throw new Error('Non autoris√© : seuls les admins peuvent supprimer des partenaires');
    }
    
    // R√©cup√©rer le partenaire avant suppression
    const partner = await Partner.findById(id);
    if (!partner) {
      throw new Error('Partenaire introuvable');
    }
    
    // Supprimer le partenaire
    await Partner.findByIdAndDelete(id);
    
    console.log('‚úÖ Partenaire supprim√©:', id);
    
    // üî• INVALIDATION CACHE COMPL√àTE
    await PartnerCache.invalidatePartner(id);
    await PartnerCache.invalidateCache();
    await cacheService.invalidateGroup('partners');
    
    // üöÄ NOTIFICATION WEBSOCKET - Partenaire supprim√©
    await websocketService.notifyPartnerChange(
      id,
      'deleted',
      {
        id: id,
        name: partner.name,
        category: partner.category,
        city: partner.city,
        deletedAt: new Date().toISOString()
      }
    );
    
    // üéØ NOTIFICATION PAR G√âOLOCALISATION
    await websocketService.notifyPartnerChangeByLocation(
      id,
      'deleted',
      { id, name: partner.name },
      partner.city,
      partner.category
    );
    
    // üîÑ NOTIFICATION INVALIDATION CACHE
    await websocketService.notifyCacheInvalidation([
      `partner:${id}`,
      'all_partners',
      `category:${partner.category}`,
      `city:${partner.city}`
    ]);
    
    console.log('üì° Notifications WebSocket envoy√©es pour suppression partenaire');
    
    return {
      success: true,
      message: `Partenaire "${partner.name}" supprim√© avec succ√®s`
    };
    
  } catch (error) {
    console.error(`‚ùå Erreur suppression partenaire ${id}:`, error);
    throw error;
  }
};
